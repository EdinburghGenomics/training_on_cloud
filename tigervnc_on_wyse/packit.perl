#!/usr/bin/perl
#packit.perl - created Tue May 27 17:14:22 BST 2014

use strict;
use warnings;

# Takes a shell (or Perl, or whatever) script and packs it to make a shar-type
# archive that can be run with "sh foo.sh" or indeed "cat foo.sh | sh".

# Note that for URLs the recipient must have either wget or curl
# In all cases the recipient needs Perl or uudecode, and gunzip, and md5sum
# The unpack script is designed to work with dash, so should work anywhere.

# You must have shar and uuencode, and wget+md5sum for the AUTO md5sum feature.

# Also note I make no promise that filenames are handled robustly, so
# avoid spaces and other gubbins, especially in the main script name.

# First, what to pack?

my $mainscript = $ARGV[0] || die "What to pack??\n";
my $msbase = $mainscript;

if( $mainscript =~ /\// )
{
    print STDERR "Warning - dependencies in script will be resolved relative to CWD.\n";
    $msbase = s/.*\///;
}

my %topack;
my %urls;
my $dir = '';  #Specific directory to unpack to if not mktemp -d
my $id = '';
my $md5 = '';
my @md5sums;
$topack{$_}++ for @ARGV; #Pack all args including main script.

# Add things from the main script.
open( my $ms, "<$mainscript" ) or die $!;

for(<$ms>)
{
    chomp;
    /^#==([FUDIM]) (.*)/ or next;

    #An ugly if/elsif chain but I don't care
    if( $1 eq 'F' )
    {
	$topack{$2}++;
    }
    elsif( $1 eq 'U' )
    {
	$urls{$2}++;
    }
    elsif( $1 eq 'D' )
    {
	$dir = $2;
    }
    elsif( $1 eq 'I' )
    {
	$id = $2;
	$id = 'root' if $id eq '0';
    }
    elsif( $1 eq 'M' )
    {
	#Warning - specifying a binary file as your md5sum file will blow
	#the system up.  Ye be warned.
	$md5 = $2;
	if($md5 =~ /^AUTO[-_]?U/) { $md5 = "AUTO-URL" }
	elsif($md5 =~ /^AUTO/){ $md5 = "AUTO-ALL" }
    }

}

sub echo { print "$_\n" for @_; }

# Generate the md5sums if asked.
if($md5 =~ /^AUTO-/ && %urls)
{
    print STDERR "Calculating md5 sums for " . keys(%urls) . " urls; this may take a while.\n";
    for(keys %urls)
    {
	#Translate the URL to a filename.  Not robust.  If you want it robust, make the
	#md5sum file yourself and specify it with #==M mymd5sums.txt
	(my $file4url = $_ ) =~ s/.*\///;
	$file4url =~ s/(%20|\+)/ /g;

	unshift @md5sums, `wget -qO- "$_" | md5sum -`;
	chomp $md5sums[0];
	$md5sums[0] =~ /^([a-f0-9]{32}\s+)-$/ or die "$_ produced bad md5sum line $md5sums[0] - aborting\n";
	$md5sums[0] = "$1$file4url";
    }
}
if($md5 =~ /^AUTO-ALL/) # This is silly as shar already checksums for you.
{
    for(keys %topack)
    {
	unshift @md5sums, `md5sum "$_"`;
	chomp $md5sums[0];
	$md5sums[0] =~ /^[a-f0-9]{32}\s+/ or die "$_ produced bad md5sum line $md5sums[0] - aborting\n";
    }
}


# Print a preamble that checks the user and changes to the right directory.
$| = 1;
echo '#!/bin/sh', ("#Script generated by packit.perl on " . localtime . "."), '';

#For root users, check the ID and fix $HOME, as the user may not have run "sudo -H"
#and this can screw up some things like R module installation.
#For other users, just check ID, unless we are just unpacking.  Anyone can unpack.
if($id eq 'root')
{
    echo 'if [ -z "$UNPACK_ONLY" -a "`id -u`" != 0 ] ; then',
         '  echo "This script needs to be run with root privileges.  Please try:"',
	 '  echo "  sudo -H sh $0"',
	 '  exit 1',
	 'fi',
	 'export HOME="`getent passwd 0 | cut -d: -f6`"';
}
elsif($id)
{
    echo 'if [ -z "$UNPACK_ONLY" -a "`id -un`" != ' . "'$id'" . ']] ; then',
         '  echo "This script needs to be run as user ' . $id . '.  Please try:"',
	 '  echo "  sudo -Hu ' . $id . ' sh $0"',
	 '  exit 1',
	 'fi';
}

# Note that whatever happens, the working dir will not be cleaned up.  I could add
# this but it seems risky.  Temp dirs are cheap and the cron removes them for you.

if($dir)
{
    echo "mkdir -p $dir", "cd $dir",
         'if [ "$?" != 0 ] ; then',
	 '  echo "Unable to change to directory" ' . $dir . ' "; cannot continue."',
	 '  exit 2',
	 'fi';
}
else
{
    echo 'cd "`mktemp -d || echo /dev/null`"',
         'if [ "$?" != 0 ] ; then',
	 '  echo "Unable to change to temporary directory; cannot continue."',
	 '  exit 2',
	 'fi';
}
echo 'echo "Working in `pwd`..."';

# Now grab all the URLs.  Fairly easy.  I could add a checksum feature, maybe.
if(%urls)
{
    echo '',
    'if which wget >/dev/null 2>&1 ; then',
    '  alias WGET="wget -c"',
    'elif which curl >/dev/null 2>&1 ; then',
    '  alias WGET="curl -o"',
    'else',
    '  echo "Cannot retrieve URLs as you have neither wget or curl commands available."',
    '  exit 3',
    'fi',
    '',
    ( map {"if ! WGET '$_' ; then exit 3 ; fi"} keys %urls ),
    '';
}

# OK, now run shar.  No need to start a subshell as far as I can see, but I do need 
# to disable exit 0 from happening, and provide a uudecode alternative, and hook my md5sum
# check.
echo '#Add hook to ensure the payload runs after successful unpacking',
     'nexit() {',
     'if [ "$1" = "0" ] ; then',
     ' do_md5_check || { echo "Checksum fail." ; exit 1 ; }',
     ' if [ -n "$UNPACK_ONLY" ] ; then',
     "  echo \"Unpack complete in `pwd`. Exiting.\"",
     ' else',
     "  chmod +x $msbase",
     "  echo 'Unpack phase complete.  Running $msbase' ; echo '====>>>'",
     "  exec ./$msbase <&1",
     ' fi',
     'else \exit "$@"',
     'fi }',
     'alias exit=nexit';

echo '#Always prefer Perl for uudecoding',
     'uudecode() {',
     ' if which perl >/dev/null ; then',
     '  read l0 l1 l2',
     "  perl -ne 'print unpack(\"u*\",\$_)' >\$l2 &&",
     '  chmod $l1 $l2',
     ' else',
     '  uudecode "$@"',
     ' fi',
     '}';

if(!$md5)
{
    echo '#No extra md5sum checking',
         'do_md5_check() {',
	 '  true',
	 '}';
}
elsif($md5 =~ /^AUTO-/)
{
    #Yes, Dash lets you embed heredocs in a function body.  How does that work??
    echo '#md5sum check.',
         "do_md5_check() { md5sum -c <<'.'",
	   @md5sums,
	 '.',
	 '}';
}
else
{
    echo 'do_md5_check() {',
	 "  md5sum -c '$md5'",
	 '}';
}

open(my $sharout, "|-", "shar -mfxzS");
print $sharout "$_\n" for keys %topack;
close $sharout;
